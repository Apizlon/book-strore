user nginx;
worker_processes auto;
error_log /var/log/nginx/error.log warn;
pid /var/run/nginx.pid;

events {
    worker_connections 1024;
}

http {
    include /etc/nginx/mime.types;
    default_type application/octet-stream;

    log_format main '$remote_addr - $remote_user [$time_local] "$request" '
                    '$status $body_bytes_sent "$http_referer" '
                    '"$http_user_agent" "$http_x_forwarded_for"';

    access_log /var/log/nginx/access.log main;

    sendfile on;
    tcp_nopush on;
    tcp_nodelay on;
    keepalive_timeout 65;
    types_hash_max_size 2048;
    client_max_body_size 20M;

    # Upstream services
    upstream auth_service {
        server auth_service:5001;
    }

    upstream user_service {
        server user_service:5002;
    }

    # Health check endpoint (no auth required)
    server {
        listen 80;
        server_name _;

        location /health {
            access_log off;
            return 200 "healthy\n";
            add_header Content-Type text/plain;
        }

        location / {
            proxy_pass http://user_service;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_set_header X-Forwarded-Host $host;
            proxy_set_header X-Forwarded-Port $server_port;

            # Auth validation for most endpoints
            access_by_lua_block {
                local uri = ngx.var.uri
                local method = ngx.req.get_method()

                -- Public endpoints that dont require authentication
                local public_endpoints = {
                    ["/auth/login"] = true,
                    ["/auth/register"] = true,
                    ["/auth/refresh"] = true,
                    ["/health"] = true,
                }

                -- Check if endpoint is public
                if public_endpoints[uri] then
                    return
                end

                -- Get authorization header
                local auth_header = ngx.var.http_authorization
                if not auth_header then
                    ngx.status = 401
                    ngx.say('{"error":"No authorization header"}')
                    return ngx.exit(401)
                end

                -- Extract token
                local token = string.match(auth_header, "Bearer%s+(.+)")
                if not token then
                    ngx.status = 401
                    ngx.say('{"error":"Invalid authorization header"}')
                    return ngx.exit(401)
                end

                -- Call auth service to validate token
                local httpc = require("resty.http").new()
                local res, err = httpc:request_uri("http://auth_service:5001/auth/validate", {
                    method = "POST",
                    headers = {
                        ["Authorization"] = "Bearer " .. token,
                        ["Content-Type"] = "application/json",
                    },
                })

                if not res then
                    ngx.status = 500
                    ngx.say('{"error":"Auth service error: ' .. err .. '"}')
                    return ngx.exit(500)
                end

                if res.status ~= 200 then
                    ngx.status = 401
                    ngx.say('{"error":"Unauthorized"}')
                    return ngx.exit(401)
                end

                -- Pass token to backend services
                ngx.req.set_header("X-User-Token", token)
            }

            proxy_redirect off;
        }
    }
}